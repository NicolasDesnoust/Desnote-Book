{
  "posts": [
    {
      "id": "2020-05-07-comment-rendre-son-footer-responsive",
      "title": "Comment rendre son footer responsive ?",
      "published": "05/07/2020",
      "content": "# Comment rendre son footer responsive ?\r\n\r\nVoici comment rendre un footer responsive uniquement en **CSS**.  le footer sera toujours placé en dessous du contenu de la page. Si cette dernière déborde il ne sera pas fixé en bas et si le contenu est trop petit il se fixera en bas de la fenêtre du navigateur.\r\n\r\n## Code\r\n\r\n```css\r\nbody { display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; }\r\n```\r\n\r\n<ul class=\"nav nav-tabs\">\r\n  <li class=\"active nav-item\"><a data-toggle=\"tab\" class=\"nav-link active show\" href=\"#CSS\">CSS</a></li>\r\n  <li class=\"nav-item\"><a data-toggle=\"tab\" class=\"nav-link\" href=\"#HTML\">HTML</a></li>\r\n</ul>\r\n\r\n<div class=\"tab-content\">\r\n  <div name=\"CSS\" class=\"tab-pane fade in active show\">\r\n\r\n```css\r\nbody {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tmin-height: 100vh;\r\n}\r\n\r\n.contenu {\r\n\tflex-grow: 1;\r\n}\r\n```\r\n\r\n  </div>\r\n  <div name=\"HTML\" class=\"tab-pane fade\">\r\n    \r\n```html\r\n<!doctype html>\r\n\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"utf-8\">\r\n\r\n\t<title>Mon site</title>\r\n\t<meta name=\"description\" content=\"Description de mon site\">\r\n\t<meta name=\"author\" content=\"Moi-même\">\r\n\r\n\t<link rel=\"stylesheet\" href=\"style.css\">\r\n</head>\r\n\r\n<body>\r\n\t<header>\r\n\t\t\r\n\t</header>\r\n\t<section class=\"contenu\">\r\n\t\t<h1>Bienvenue sur mon site !</h1>\r\n\r\n\t\t<p>\r\n\t\t\tPour tester l'aspect responsive du footer, essayer \r\n\t\t\tde rajouter ou d'enlever du contenu ici et de \r\n\t\t\tredimensionner la fênetre du navigateur.\r\n\t\t</p>\r\n\t</section>\r\n\t<footer>\r\n\t\t\r\n\t</footer>\r\n</body>\r\n</html>\r\n```\r\n\r\n</div>\r\n</div>",
      "authorId": "nicolas-desnoust",
      "tags": [
        "css",
        "footer",
        "responsive",
        "html"
      ],
      "category": "css"
    },
    {
      "id": "2020-05-07-dev-api-rest-avec-spring",
      "title": "Développement d'une API REST avec Spring",
      "published": "05/07/2020",
      "content": "# Développement d'une API REST avec Spring\r\n\r\n## Introduction\r\nCe mini-tutoriel permet d'explorer les possibilités de **Github Pages** et de la rédaction de tutoriels en **Markdown**. \r\nIl s'agit principalement de présenter comment réaliser rapidement les fondements d'une **API REST** à l'aide du framework **Spring**.\r\n> **Attention :** Ce tutoriel n'est actuellement pas complet. \r\n\r\n### Technologies\r\nVoici une liste exhaustive des technologies qui seront employées :\r\n\r\n - Spring REST\r\n - Spring Boot / Spring Initializr\r\n - Spring Data\r\n - Maven\r\n - Lombok\r\n - MySQL\r\n - JPA / Hibernate\r\n\r\n## Création du projet sur Spring Initializr\r\n\r\nLa première étape consite à créer les sources du projet Maven en remplissant le formulaire de [Spring Initializr](https://start.spring.io).\r\n\r\nCe dernier devrait se présenter sous la forme suivante :\r\n\r\n![Aperçu de SPring Initializr](https://i.imgur.com/SBl70J1.png)\r\n\r\n## Import sous Eclipse\r\n\r\n## Configuration de la base de données\r\n\r\nLa configuration de la base de données se réalise dans le fichier `src/main/resources/app.properties` :\r\n```properties\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.jpa.hibernate.show_sql=true\r\n\r\n# Configuration pour MySQL 8 (L'url, le username et le password sont à changer).\r\nspring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect\r\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\nspring.datasource.url=jdbc:mysql://localhost:3306/<nom-de-la-BDD>?serverTimezone=Europe/Berlin\r\nspring.datasource.username=<identifiant>\r\nspring.datasource.password=<mot-de-passe>\r\n\r\n######### Configuration pour HSQLDB\r\n#spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\r\n#spring.datasource.driver-class-name=org.hsqldb.jdbcDriver\r\n#spring.datasource.url=jdbc:hsqldb:file:data/ADM;shutdown=true;hsqldb.write_delay=false\r\n#spring.datasource.username=sa\r\n#spring.datasource.password=\r\n```\r\n\r\n## Coloration syntaxique en Java\r\n```java\r\npackage adm.entities.education;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.JoinColumn;\r\nimport javax.persistence.JoinTable;\r\nimport javax.persistence.ManyToMany;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.Table;\r\n\r\nimport lombok.AccessLevel;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonIgnore;\r\n\r\nimport adm.entities.AbstractEntity;\r\nimport adm.entities.association.Association;\r\nimport adm.entities.referentials.domain.Domain;\r\nimport adm.entities.referentials.organism.Organism;\r\nimport adm.entities.referentials.teachingmodality.TeachingModality;\r\nimport adm.entities.referentials.teachingsite.TeachingSite;\r\nimport adm.entities.referentials.typeofdegree.TypeOfDegree;\r\n\r\n@Entity\r\n@Table(name = \"FORMATION\")\r\n@Getter @Setter\r\n@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = true)\r\npublic class Education extends AbstractEntity {\r\n\r\n\t@Getter(AccessLevel.NONE) @Setter(AccessLevel.NONE)\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@ManyToOne\r\n\t@JoinColumn(name = \"CODE_TYPE_DIPLOME\", referencedColumnName = \"CODE\")\r\n\tprivate TypeOfDegree type;\r\n\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_DOM\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_DOMAINE\"))\r\n\tprivate Set<Domain> domains;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_ORG\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_ORGANISME\"))\r\n\tprivate Set<Organism> organisms;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_MOD\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_MODALITE\"))\r\n\tprivate Set<TeachingModality> modalities;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_SIT\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_SITE\"))\r\n\tprivate Set<TeachingSite> sites;\r\n\t\r\n\t@JsonIgnore\r\n\t@OneToMany(mappedBy = \"id.education\")\r\n\tprivate Collection<Association> associations;\r\n\t\r\n\tpublic Education() {\r\n\t\tdomains = new HashSet<Domain>();\r\n\t\torganisms = new HashSet<Organism>();\r\n\t\tmodalities = new HashSet<TeachingModality>();\r\n\t}\r\n}\r\n```\r\n## Coloration syntaxique en HTML\r\n```html\r\n<!doctype html>\r\n\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n\t\r\n    <title>The HTML5 Herald</title>\r\n    <meta name=\"description\" content=\"The HTML5 Herald\">\r\n    <meta name=\"author\" content=\"SitePoint\">\r\n\r\n    <link rel=\"stylesheet\" href=\"css/styles.css?v=1.0\">\r\n</head>\r\n\r\n<body>\r\n    <script src=\"js/scripts.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\nStackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible **offline!**\r\n\r\n## Create files and folders\r\n\r\nThe file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the **New file** button in the file explorer. You can also create folders by clicking the **New folder** button.\r\n\r\n## Switch to another file\r\n\r\nAll your files and folders are presented as a tree in the file explorer. You can switch from one to another by clicking a file in the tree.\r\n\r\n## Rename a file\r\n\r\nYou can rename the current file by clicking the file name in the navigation bar or by clicking the **Rename** button in the file explorer.\r\n\r\n## Delete a file\r\n\r\nYou can delete the current file by clicking the **Remove** button in the file explorer. The file will be moved into the **Trash** folder and automatically deleted after 7 days of inactivity.\r\n\r\n## Export a file\r\n\r\nYou can export the current file by clicking **Export to disk** in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.\r\n\r\n\r\n# Synchronization\r\n\r\nSynchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your **Google Drive**, your **Dropbox** and your **GitHub** accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow... The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.\r\n\r\nThere are two types of synchronization and they can complement each other:\r\n\r\n- The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device.\r\n\t> To start syncing your workspace, just sign in with Google in the menu.\r\n\r\n- The file synchronization will keep one file of the workspace synced with one or multiple files in **Google Drive**, **Dropbox** or **GitHub**.\r\n\t> Before starting to sync files, you must link an account in the **Synchronize** sub-menu.\r\n\r\n## Open a file\r\n\r\nYou can open a file from **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Open from**. Once opened in the workspace, any modification in the file will be automatically synced.\r\n\r\n## Save a file\r\n\r\nYou can save any file of the workspace to **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Save on**. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.\r\n\r\n## Synchronize a file\r\n\r\nOnce your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.\r\n\r\nIf you just have modified your file and you want to force syncing, click the **Synchronize now** button in the navigation bar.\r\n\r\n> **Note:** The **Synchronize now** button is disabled if you have no file to synchronize.\r\n\r\n## Manage file synchronization\r\n\r\nSince one file can be synced with multiple locations, you can list and manage synchronized locations by clicking **File synchronization** in the **Synchronize** sub-menu. This allows you to list and remove synchronized locations that are linked to your file.\r\n\r\n\r\n# Publication\r\n\r\nPublishing in StackEdit makes it simple for you to publish online your files. Once you're happy with a file, you can publish it to different hosting platforms like **Blogger**, **Dropbox**, **Gist**, **GitHub**, **Google Drive**, **WordPress** and **Zendesk**. With [Handlebars templates](http://handlebarsjs.com/), you have full control over what you export.\r\n\r\n> Before starting to publish, you must link an account in the **Publish** sub-menu.\r\n\r\n## Publish a File\r\n\r\nYou can publish your file by opening the **Publish** sub-menu and by clicking **Publish to**. For some locations, you can choose between the following formats:\r\n\r\n- Markdown: publish the Markdown text on a website that can interpret it (**GitHub** for instance),\r\n- HTML: publish the file converted to HTML via a Handlebars template (on a blog for example).\r\n\r\n## Update a publication\r\n\r\nAfter publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the **Publish now** button in the navigation bar.\r\n\r\n> **Note:** The **Publish now** button is disabled if your file has not been published yet.\r\n\r\n## Manage file publication\r\n\r\nSince one file can be published to multiple locations, you can list and manage publish locations by clicking **File publication** in the **Publish** sub-menu. This allows you to list and remove publication locations that are linked to your file.\r\n\r\n\r\n# Markdown extensions\r\n\r\nStackEdit extends the standard Markdown syntax by adding extra **Markdown extensions**, providing you with some nice features.\r\n\r\n> **ProTip:** You can disable any **Markdown extension** in the **File properties** dialog.\r\n\r\n\r\n## SmartyPants\r\n\r\nSmartyPants converts ASCII punctuation characters into \"smart\" typographic punctuation HTML entities. For example:\r\n\r\n|                |ASCII                          |HTML                         |\r\n|----------------|-------------------------------|-----------------------------|\r\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\r\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\r\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\r\n\r\n\r\n## KaTeX\r\n\r\nYou can render LaTeX mathematical expressions using [KaTeX](https://khan.github.io/KaTeX/):\r\n\r\nThe *Gamma function* satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral\r\n\r\n$$\r\n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\r\n$$\r\n\r\n> You can find more information about **LaTeX** mathematical expressions [here](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference).\r\n\r\n\r\n## UML diagrams\r\n\r\nYou can render UML diagrams using [Mermaid](https://mermaidjs.github.io/). For example, this will produce a sequence diagram:\r\n\r\n```mermaid\r\nsequenceDiagram\r\nAlice ->> Bob: Hello Bob, how are you?\r\nBob-->>John: How about you John?\r\nBob--x Alice: I am good thanks!\r\nBob-x John: I am good thanks!\r\nNote right of John: Bob thinks a long<br/>long time, so long<br/>that the text does<br/>not fit on a row.\r\n\r\nBob-->Alice: Checking with John...\r\nAlice->John: Yes... John, how are you?\r\n```\r\n\r\nAnd this will produce a flow chart:\r\n\r\n```mermaid\r\ngraph LR\r\nA[Square Rect] -- Link text --> B((Circle))\r\nA --> C(Round Rect)\r\nB --> D{Rhombus}\r\nC --> D\r\n```\r\n\r\n",
      "authorId": "nicolas-desnoust",
      "tags": [
        "css",
        "footer",
        "responsive",
        "html"
      ],
      "category": "spring"
    },
    {
      "id": "2020-08-10-setup-vscode",
      "title": "Setup de Visual Studio Code",
      "published": "08/10/2020",
      "content": "# Setup de Visual Studio Code\r\n\r\n## Extensions utiles à tout type de projet\r\n\r\n| Nom                       | Auteur     | Description                                                  |\r\n| ------------------------- | ---------- | ------------------------------------------------------------ |\r\n| Better comments           | Aaron Bond | Permet de catégoriser les commentaires (alertes, questions, TODOs, commentaires importants, à ignorer). |\r\n| Prettier - Code formatter | Prettier   | Formateur de code (nécessaire pour les langages CSS/SCSS non-supportés par défaut). |\r\n\r\n## Installation d'une police avec ligatures\r\n\r\n1. **Installer les polices** \r\n\r\n   Téléchargez la police Firacode ici : [**https://github.com/tonsky/FiraCode**](https://github.com/tonsky/FiraCode) et installez le contenu du dossier `ttf` sur votre système d'exploitation. \r\n\r\n2. **Configurer Visual Studio Code**\r\n\r\n   Ouvrez les préférences utilisateur à l'aide de la commande **Ctrl+Shift+P** et recherchez `Preferences: Open Settings (UI)`. \r\n\r\n   Pour activer la police précédemment téléchargée, dans l'éditeur des paramètres, cliquez sur `Font` sous l'onglet `Text Editor`. Dans le champ `Font Family` ajoutez `'Fira Code'` (avec les guillemets simple) en premier dans la liste. Cochez ensuite la case `Enable/Disable font ligatures` sous `Font Ligatures` pour activer les ligatures.",
      "authorId": "nicolas-desnoust",
      "tags": [
        "vscode",
        "extension",
        "police"
      ],
      "category": "vscode"
    },
    {
      "id": "2020-23-10-introduction-spring",
      "title": "Une (petite) introduction à Spring",
      "content": "## Introduction\n\nLe framework [Spring](http://www.springframework.org/) est une boite à outils très riche permettant de structurer, d'améliorer et de simplifier l'écriture d'application JEE. Spring est organisé en module :\n\n- Gestion des instances de classes (JavaBean et/ou métier),\n- Programmation orientée Aspect,\n- Modèle MVC et outils pour les applications WEB,\n- Outils pour la DAO (JDBC),\n- Outils pour les ORM (Hibernate, iBatis, ...),\n- Outils pour les applications JEE (JMX, JMA, JCA, EJB, ...).\n\n[Plus d'informations ici](https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/overview.html).\n\n## Programmation par contrat\n\nTravail à faire :\n\n- Lancez Eclipse JEE (commande eclipse). Si la commande n'est pas disponible, téléchargez directement [Eclipse JEE](http://jean-luc.massat.perso.luminy.univ-amu.fr/ens/jee-pour-M2/ress/).\n- Préparez un projet Java standard pour tester les exemples présentés ci-dessous.\n\n### Principe\n\nLa programmation par contrat consiste à séparer la spécification d'une couche logicielle (aussi appelée service) de sa réalisation. La spécification donne lieu à la création d'une interface et la réalisation fournit une classe qui implante cette interface. Ce ne sont pas nécessairement les mêmes personnes qui développent l'interface et son implantation. On peut également remarquer que la phase de réalisation peut produire plusieurs implantations différentes d'une même interface. Le choix entre ces implantations est réalisé à l'intégration entre les couches. Les objectifs de cette approche :\n\n- **Réduire les dépendances.**\n\n Les classes d'implantation ne se connaissent pas. Elles dialoguent au moyen des interfaces. De ce fait, on peut facilement changer un implantation contre une autre sans avoir à mettre à jour la totalité du logiciel.\n\n- **Faciliter les tests.**\n\n Chaque couche logicielle ayant une spécification claire, il est facile de lui associer un jeu de tests utilisable quelque soit la nature de l'implantation.\n\n- **Simplifier le code.**\n\n Dans certains cas de figure, le code d'une méthode est une suite de considérations sans liaison directe entre-elles. La programmation par contrat va faciliter la construction d'implantations façade qui se chargent chacune d'une partie du travail.\n\n- **Organiser le développement.**\n\n### Spécifier un service logiciel\n\nPrenons un exemple pour éclairer ces principes. Nous avons besoin dans nos applications de pouvoir tracer un certain nombre d'évènements. Nous allons donc créer un service de trace (un *logger* en anglais). Ce service est spécifié par l'interface ci-dessous :\n\n```java\npackage myapp.services;\n\npublic interface ILogger {\n\n    default void log(String message) {  };\n\n}\n```\n\n### Une première implantation\n\nPour utiliser ce service, nous avons besoin d'une classe qui implante ce service. Il existe plusieurs manières de faire. Nous allons, dans une premier temps, envoyer les messages de trace sur la console de sortie d'erreur standard :\n\n```java\npackage myapp.imp;\n\nimport java.util.Date;\n\nimport myapp.services.ILogger;\n\npublic class StderrLogger implements ILogger {\n\n    public void start() {\n        System.err.println(\"Start \" + this);\n    }\n\n    public void stop() {\n        System.err.println(\"Stop \" + this);\n    }\n\n    @Override\n    public void log(String message) {\n        System.err.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\n    }\n\n}\n```\n\nLes méthodes start et stop correspondent à la phase de démarrage et de terminaison du service. Nous retrouverons ces méthodes dans toutes les implantations (même si elles sont vides).\n\n A propos des packages. Vous pouvez noter dans cet exemple que l'interface est dans un package et que la classe d'implantation est dans un autre. Dans un cas réel, la spécification d'un service peut être composé de plusieurs interfaces accompagnées de javaBeans ou de classes d'exception. L'implantation de ce service peut également contenir plusieurs classes ce qui justifie clairement l'utilisation de plusieurs packages.\n\nNous pouvons maintenant utiliser ce service. Pour ce faire, nous allons construire une classe de test unitaire (avec JUnit 5 à ajouter dans le buildpath de votre projet Eclipse) :\n\n```java\npackage myapp.tests;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport myapp.imp.StderrLogger;\nimport myapp.services.ILogger;\n\npublic class TestLoggerServices {\n\n    @BeforeEach\n    public void beforeEachTest() {\n        System.err.println(\"====================\");\n    }\n\n    @AfterEach\n    public void afterEachTest() {\n    }\n\n    // use a logger\n    void use(ILogger logger) {\n        logger.log(\"Voila le résultat = hello\");\n    }\n\n    // Test StderrLogger\n    @Test\n    public void testStderrLogger() {\n        // create the service\n        var logger = new StderrLogger();\n        // start the service\n        logger.start();\n        // use the service\n        use(logger);\n        // stop the service\n        logger.stop();\n    }\n\n}\n```\n\nA ce stade, nous pouvons remarquer que :\n\n Les utilisateurs (la méthode use ci-dessus) n'ont aucune connaissance des détails de l'implantation. Seule l'interface est utilisée.\n Il existe tout de même une dépendance puisque le nom de la classe d'implantation apparaît en clair dans le code de l'utilisateur (méthode testStderrLogger).\n L'intégrateur (methode testStderrLogger) est responsable du respect du contrat (on appelle d'abord start, puis on utilise, puis on appelle stop).\n\n### Une deuxième implantation\n\nNous pouvons aussi donner une deuxième implantation qui stocke les traces dans un fichier :\n\n```java\npackage myapp.imp;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Date;\n\nimport myapp.services.ILogger;\n\npublic class FileLogger implements ILogger {\n\n    // parameter: the writer\n    private final PrintWriter writer;\n\n    public FileLogger(String fileName) {\n        try {\n            this.writer = new PrintWriter(new FileOutputStream(fileName, true));\n        } catch (FileNotFoundException e) {\n            throw new IllegalArgumentException(\"bad fileName\");\n        }\n    }\n\n    public void start() {\n        System.err.println(\"Start \" + this);\n    }\n\n    public void stop() {\n        writer.close();\n        System.err.println(\"Stop \" + this);\n    }\n\n    @Override\n    public void log(String message) {\n        writer.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\n    }\n\n}\n```\n\nCette nouvelle implantation a absolument besoin d'un paramètre (le nom du fichier) pour être fonctionnelle. La solution retenue est la plus simple : ajouter un argument au constructeur. Nous remarquons que de ce fait, la méthode start n'a plus vraiment d'intérêt.\n\nOn remarque que le code d'intégration est très peu modifié (une ligne), alors que le fonctionnement est totalement différent. On remarque également que le code d'utilisation (méthode use) n'est pas altéré. Les modifications portent uniquement sur le code d'intégration :\n\n```java\n@Test\npublic void testFileLogger() {\n    var logger = new FileLogger(\"/tmp/myapp.log\");\n    logger.start();\n    use(logger);\n    logger.stop();\n}\n```\n\n### Une troisième implantation\n\nLa plupart des classes d'implantation ont besoin de paramètres pour assurer leur service. Le choix de placer ces paramètres en argument du constructeur pose plusieurs problèmes :\n\n-  La classe obtenue n'est pas un javaBean (pas de constructeur vide). C'est particulièrement gênant car l'intérêt de ces composants élémentaires est très important.\n-  Les paramètres du service sont fixés à sa création (par le constructeur). Il n'est donc pas possible de les changer en cours de route, voir même d'envisager un recyclage du service (changement des paramètres et nouvelle initialisation).\n-  Si nous avons beaucoup de paramètres, le constructeur est difficile à utiliser.\n-  Il n'est pas possible de prévoir des valeurs par défaut pour certains paramètres.\n\nNous allons donc introduire une nouvelle solution au problème des paramètres : les paramètres vont être codés comme des propriétés de la classe d'implantation et la méthode start devra les utiliser pour initialiser le service. Nous obtenons donc cette nouvelle version :\n\n```java\npackage myapp.imp;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Date;\n\nimport myapp.services.ILogger;\n\npublic class BeanFileLogger implements ILogger {\n\n    // parameter: writer name\n    private String fileName;\n\n    // property: writer\n    private PrintWriter writer;\n\n    // start service\n    public void start() {\n        if (fileName == null) {\n            throw new IllegalStateException(\"no fileName\");\n        }\n        try {\n            OutputStream os = new FileOutputStream(fileName, true);\n            this.writer = new PrintWriter(os);\n        } catch (FileNotFoundException e) {\n            throw new IllegalStateException(\"bad fileName\");\n        }\n        System.err.println(\"Start \" + this);\n    }\n\n    // stop service\n    public void stop() {\n        writer.close();\n        System.err.println(\"Stop \" + this);\n    }\n\n    @Override\n    public void log(String message) {\n        writer.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    public void setFileName(String fileName) {\n        this.fileName = fileName;\n    }\n\n}\n```\n\nLe code d'intégration a maintenant la responsabilité de fixer les paramètres du service avant d'appeler la méthode d'initialisation. Cette solution est plus simple et plus systématique quand le nombre de paramètres est important :\n\n```java\n@Test\npublic void testBeanFileLogger() {\n    // create the service\n    var logger = new BeanFileLogger();\n    // set parameter\n    logger.setFileName(\"/tmp/myapp.log\");\n    // start\n    logger.start();\n    // use\n    use(logger);\n    // stop\n    logger.stop();\n}\n```\n\nTravail à faire : En donnant une valeur par défaut au paramètre de la classe BeanFileLogger nous pouvons rendre optionnelle la phase de paramétrage. mettez en oeuvre et testez ce principe.\n\n## Injection des dépendances\n\nL'injection des dépendances traite le délicat problème de la communication et de la dépendance entre services logiciels. Prenons l'exemple d'une classe métier :\n\n```java\npackage myapp.services;\n\npublic interface ICalculator {\n\n    int add(int a, int b);\n\n}\n```\n\nConstruisons maintenant une implantation de ce service qui génère une trace après chaque appel d'une méthode métier. Cette implantation a donc besoin d'une couche logger pour s'exécuter correctement. Nous pourrions envisager de placer dans cette implantation la propriétés suivante :\n\n```java\npackage myapp.imp;\n\nimport myapp.services.ICalculator;\nimport myapp.services.ILogger;\n\npublic class SimpleCalculator implements ICalculator {\n\n    private ILogger logger = new myapp.imp.StderrLogger();\n\n    ...\n}\n```\n\nCette solution pose deux problèmes :\n\n1. Une dépendance directe vient d'être introduite entre cette implantation de la calculatrice et une implantation particulière de la couche logger. Cette dépendance est regrettable car inutile. La calculatrice doit utiliser l'interface ILogger et pas une implantation.\n2. Si nous avions choisi une couche de trace ayant besoin d'un paramètre (comme celle vue précédemment), nous aurions sans doute dû inclure ce paramètre (le fichier de sortie) comme un paramètre de la calculatrice. En d'autres termes, les paramètres d'une couche A doivent inclure tous les paramètres des couches utilisées par A.\n\nPour éviter ces problèmes, nous allons simplement introduire dans l'implantation de la calculatrice un paramètre faisant référence à une implantation de la couche logger. De ce fait, les deux implantations resteront indépendantes l'une de l'autre. Le seul point de contact sera l'interface ILogger :\n\n```java\npackage myapp.imp;\n\nimport myapp.services.ICalculator;\nimport myapp.services.ILogger;\n\npublic class SimpleCalculator implements ICalculator {\n\n    private ILogger logger;\n\n    public void start() {\n        if (logger == null) {\n            throw new IllegalStateException(\"null logger\");\n        }\n        System.err.println(\"Start \" + this);\n    }\n\n    public void stop() {\n        System.err.println(\"Stop \" + this);\n    }\n\n    public int add(int a, int b) {\n        logger.log(String.format(\"add(%d,%d)\", a, b));\n        return (a + b);\n    }\n\n    public ILogger getLogger() {\n        return logger;\n    }\n\n    public void setLogger(ILogger logger) {\n        this.logger = logger;\n    }\n\n}\n```\n\nLa phase d'intégration devient plus délicate puisqu'il faut créer et initialiser deux couches logicielles (il faut ajouter une clause import pour assertEquals) :\n\n```java\nvoid use(ICalculator calc) {\n    assertEquals(300, calc.add(100, 200));\n}\n\n@Test\npublic void testCalculorAndStderrLogger() {\n    // create and start the logger service (on stderr)\n    var logger = new StderrLogger();\n    logger.start();\n    // create, inject and start the calculator service\n    var calculator = new SimpleCalculator();\n    calculator.setLogger(logger);\n    calculator.start();\n    // use the calculator service\n    use(calculator);\n    // stop the calculator service\n    calculator.stop();\n    // stop the logger service\n    logger.stop();\n}\n```\n\nNous pouvons très facilement et sans modifier la couche métier changer la politique de trace en utilisant un fichier. Il suffit de changer les quatre premières lignes du code d'intégration :\n\n```java\n// create file logger\nvar logger = new BeanFileLogger();\nlogger.setFileName(\"/tmp/myapp.log\");\nlogger.start();\n```\n\nNous venons de mettre en oeuvre le principe de l'injection de dépendances. C'est la partie intégration qui se charge d'injecter dans la couche métier la référence vers la couche logger. Initialiser une application revient à créer les couches logicielles, injecter les dépendances et appeler les méthodes d'initialisation.\n\n## Gestion des beans par Spring\n\nLa création des instances de javaBeans, l'injection des dépendances et le nommage des instances sont le coeur du framework Spring. Nous allons donc reprendre ces exemples en utilisant les outils fournis par Spring.\n\n### Installation de Spring\n\nPour intégrer à votre projet le framework Spring et ses dépendances, nous allons utiliser Maven :\n\n-  Ajoutez Maven à votre projet : Sélectionnez votre projet / Bouton-droit / Configure / Convert to Maven Project. Vous devez à cette étape donner une numéro de version à votre projet. Laissez les valeurs par défaut.\n-  L'action précédente a généré un fichier pom.xml qui est le coeur de la configuration de Maven. L'éditeur de ce fichier doit être ouvert. Ajoutez la dépendance ci-dessous (tirée de la page de chargement du site WEB de Spring):\n\n```xml\n<dependencies>\n    <!-- pour utiliser Spring -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.4.RELEASE</version>\n    </dependency>\n    \n    <!-- pour utiliser la partie test de Spring -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.2.4.RELEASE</version>\n    </dependency>\n    \n    <!-- pour les annotations (à partir de java 10) -->\n    <dependency>\n        <groupId>javax.annotation</groupId>\n        <artifactId>javax.annotation-api</artifactId>\n        <version>1.3.2</version>\n    </dependency>\n</dependencies>\n```\n\n-  Vous devez avoir dans votre projet un répertoire Maven dependencies qui liste les .jar de Spring.\n-  Préparez, dans un navigateur, un onglet vers la la documentation Spring.\n\n### Callbacks par annotations\n\nNous allons commencer par utiliser des annotations standards (non liées directement à Spring) pour indiquer dans nos classes les méthodes d'initialisation (@PostConstruct) et de terminaison (@PreDestroy). Ces méthodes seront automatiquement appelées par Spring.\n\n```java\npackage myapp.imp;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n...\n\n    public class StderrLogger implements ILogger {\n\n        ...\n\n            // start service\n            @PostConstruct\n            public void start() {\n            ...\n        }\n\n        // stop service\n        @PreDestroy\n        public void stop() {\n            ...\n        }\n\n        ...\n\n    }\n```\n\nÀ faire : ajoutez ces annotations à SimpleCalculator.java.\n\n### Créer et utiliser des javaBeans\n\nDans Spring, la définition des javaBeans, leurs noms et leurs paramètres sont définis dans un fichier de configuration au format XML. Une fois ce fichier préparé, Spring est capable de créer les classes de service en effectuant les injections de dépendances et les initialisations nécessaires.\n\nPréparez dans votre projet le fichier XML config.xml suivant dans le répertoire src :\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context\n                           http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- pour utiliser les annotations -->\n    <context:annotation-config />\n\n    <!-- logger sur Stderr (logger par défaut)-->\n    <bean id=\"stderrLogger\" class=\"myapp.imp.StderrLogger\" primary=\"true\" />\n\n    <!-- logger sur /tmp/myapp.log -->\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\n        <property name=\"fileName\">\n            <value>/tmp/myapp.log</value>\n        </property>\n    </bean>\n\n    <!-- calculatrice qui trace sur Stderr -->\n    <bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\">\n        <property name=\"logger\" ref=\"stderrLogger\" />\n    </bean>\n\n</beans>\n```\n\nNous allons pouvoir utiliser Spring pour exploiter la calculatrice et le logger :\n\n```java\npackage myapp.tests;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport myapp.services.ICalculator;\nimport myapp.services.ILogger;\n\npublic class TestSpring {\n\n    @BeforeEach\n    public void beforeEachTest() {\n        System.err.println(\"====================\");\n    }\n\n    void use(ILogger logger) {\n        logger.log(\"Voila le résultat\");\n    }\n\n    void use(ICalculator calc) {\n        assertEquals(300, calc.add(100, 200));\n    }\n\n    @Test\n    public void testStderrLogger() {\n        System.err.println(\"+++ StderrLogger\");\n        var conf = \"config.xml\";\n\n        // create a context and find beans\n        try (var ctx = new ClassPathXmlApplicationContext(conf);) {\n            var logger = ctx.getBean(\"stderrLogger\", ILogger.class);\n            use(logger);\n        }\n    }\n\n    @Test\n    public void testCalculatorWithLogger() {\n        System.err.println(\"+++ CalculatorWithLogger\");\n        var conf = \"config.xml\";\n\n        // create a context and find beans\n        try (var ctx = new ClassPathXmlApplicationContext(conf);) {\n            var calc = ctx.getBean(\"calculator\", ICalculator.class);\n            use(calc);\n        }\n    }\n\n}\n```\n\nSi nous voulons changer le logger de la calculatrice, il n'est pas nécessaire de modifier notre programme. Il suffit de changer le fichier XML :\n\n```xml\n<!-- calculatrice qui trace sur un fichier -->\n<bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\">\n    <property name=\"logger\" ref=\"fileLogger\" />\n</bean>\n```\n\nTestez cette nouvelle version.\n\nNous pouvons même avoir deux versions de la calculatrice en fonction de la trace choisie.\n\nVous pouvez parcourir avec profit les trois premières sections de ce chapitre.\n\n## Utilisez les annotations de Spring\n\nDepuis java 1.5, le framework Spring est également capable de décrire la configuration des beans par un jeu d'annotations. Nous allons pouvoir décrire l'injection de dépendances et la création des instances de manière déclarative et laisser le soin à Spring de réaliser les opérations.\n\n### Injection par annotation\n\nDans la classe SimpleCalculator, indiquez par une annotation (@Autowired) que vous souhaitez l'injection d'un classe logger :\n\n```java\npackage myapp.imp;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n...\n\n    public class SimpleCalculator implements ICalculator {\n\n        ...\n\n            public ILogger getLogger() {\n            return logger;\n        }\n\n        @Autowired\n        public void setLogger(ILogger logger) {\n            this.logger = logger;\n        }\n\n    }\n```\n\nLe code XML est maintenant simplifié :\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context\n                           http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- pour utiliser les annotations -->\n    <context:annotation-config />\n\n    <!-- logger sur Stderr (logger par défaut)-->\n    <bean id=\"stderrLogger\" class=\"myapp.imp.StderrLogger\" primary=\"true\" />\n\n    <!-- logger sur /tmp/myapp.log -->\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\n        <property name=\"fileName\">\n            <value>/tmp/myapp.log</value>\n        </property>\n    </bean>\n\n    <!-- calculatrice qui trace sur Stderr -->\n    <bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\" />\n\n</beans>\n```\n\nL'injection, c'est à dire la liaison entre la classe utilisée et la classe utilisatrice, se réalise sur la base du type (ici l'interface ILogger) et du nom (ici « logger »).\n\nNote : Il ya deux versions du logger (stderrLogger et fileLogger). L'attribut primary indique le service choisi par défaut.\n\n### Déclarer les services par annotation\n\nNous pouvons également déclarer une classe comme étant un service. Cette annotation va permettre de l'instancier automatiquement en cas de besoin. Appliquons ce principe sur la classe StderrLogger (et faites la même chose sur SimpleCalculator) :\n\n```java\npackage myapp.imp;\n\n...\n    \nimport org.springframework.context.annotation.Primary;\nimport org.springframework.stereotype.Service;\n\n@Service(\"stderrLogger\")\n@Primary\npublic class StderrLogger implements ILogger {\n\n    ...\n\n}\n```\n\nLe code XML devient maintenant beaucoup plus simple :\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context\n                           http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!-- pour utiliser les annotations -->\n    <context:annotation-config />\n\n    <!-- pour trouver les classes de service -->\n    <context:component-scan base-package=\"myapp.imp\" />\n\n    <!-- logger sur /tmp/myapp.log -->\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\n        <property name=\"fileName\">\n            <value>/tmp/myapp.log</value>\n        </property>\n    </bean>\n\n</beans>\n```\n\n### Contrôler les implantations choisies\n\nIl existe souvent plusieurs implantations concurrentes d'un même service et nous avons besoin de contrôler le choix lors des injections.\n\n-  Supprimez l'annotation @Primary de StderrLogger.\n-  À ce stade vous devez obtenir une erreur indiquant que deux classes sont disponibles pour l'interface ILogger.\n-  Vous pouvez d'une part ajouter une clause @Qualifier à la classe StderrLogger:\n\n```java\npackage myapp.imp;\n\n...\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\n@Qualifier(\"test\")\npublic class StderrLogger implements ILogger {\n\n    ...\n\n}\n```\n\n et ajouter la même annotation dans la classe SimpleCalculator:\n\n```java\npackage myapp.imp;\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.beans.factory.annotation.Autowired;\n...\n\n    public class SimpleCalculator implements ICalculator {\n\n        ...\n\n            @Autowired\n            @Qualifier(\"test\")\n            public void setLogger(ILogger logger) {\n            this.logger = logger;\n        }\n\n    }\n```\n\nDécouvrez d'autres possibilités de @Qualifier.\n\nDécouvrez d'autres possibilités des annotations.\n\n## Intégration JUnit / Spring\n\nAfin de rendre nos tests unitaires plus simples, nous pouvons utiliser une meilleure intégration de Spring et de Junit et injecter des beans directement dans la classe de test :\n\n```java\npackage myapp.tests;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\nimport myapp.services.ICalculator;\nimport myapp.services.ILogger;\n\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(locations = \"/config.xml\")\npublic class TestSpringJUnitIntegration {\n\n    @Autowired\n    ILogger logger;\n\n    @Autowired\n    ICalculator calc;\n\n    @BeforeEach\n    public void beforeEachTest() {\n        System.err.println(\"====================\");\n    }\n\n    void use(ILogger logger) {\n        logger.log(\"Voila le résultat\");\n    }\n\n    void use(ICalculator calc) {\n        assertEquals(300, calc.add(100, 200));\n    }\n\n    @Test\n    public void testStderrLogger() {\n        System.err.println(\"+++ StderrLogger\");\n        use(logger);\n    }\n\n    @Test\n    public void testCalculatorWithLogger() {\n        use(calc);\n    }\n\n}\n```\n\n## Configurer en Java\n\nNous avons la possibilité, depuis la version 3, de configurer Spring en utilisant une classe et des annotations. Découvrez cette technique et créez de nouvelles versions de la couche BeanFileLogger.\n\n1. Débutez par la création d'une classe de configuration. Elle remplace complètement le fichier XML et, via des méthodes annotées @Bean, propose la création de services :\n\n   ```java\n   package myapp.tests;\n   \n   import org.springframework.beans.factory.annotation.Qualifier;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.ComponentScan;\n   import org.springframework.stereotype.Component;\n   \n   import myapp.imp.BeanFileLogger;\n   import myapp.services.ILogger;\n   \n   @Component\n   @ComponentScan(\"myapp.imp\")\n   public class AppConfig {\n   \n       @Bean\n       @Qualifier(\"file\")\n       public ILogger myLogger() {\n           var logger = new BeanFileLogger();\n           logger.setFileName(\"/tmp/essai.log\");\n           System.err.println(\"Production de \" + logger);\n           return logger;\n       }\n   \n   }\n   ```\n\n2. Nous pouvons créer un simple test pour construire un contexte et récupérer une instance :\n\n   ```java\n   package myapp.tests;\n   \n   import org.junit.jupiter.api.Test;\n   import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n   \n   import myapp.imp.StderrLogger;\n   import myapp.services.ILogger;\n   \n   public class TestAppConfig {\n   \n       /*\n        * Construction d'un contexte classique\n        */\n       @Test\n       public void testStderrLogger() {\n           try (var c = new AnnotationConfigApplicationContext(AppConfig.class)) {\n               var logger = c.getBean(StderrLogger.class);\n               logger.log(\"hello on stderr\");\n           }\n       }\n   }\n   ```\n\n3. Nous pouvons également utiliser l'intégration Spring/Junit pour récupérer et tester plusieurs services :\n\n   ```java\n   package myapp.tests;\n   \n   import static org.junit.jupiter.api.Assertions.assertEquals;\n   \n   import org.junit.jupiter.api.Test;\n   import org.junit.jupiter.api.extension.ExtendWith;\n   \n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.beans.factory.annotation.Qualifier;\n   import org.springframework.context.ApplicationContext;\n   import org.springframework.test.context.ContextConfiguration;\n   import org.springframework.test.context.junit.jupiter.SpringExtension;\n   \n   import myapp.imp.StderrLogger;\n   import myapp.services.ICalculator;\n   import myapp.services.ILogger;\n   \n   @ExtendWith(SpringExtension.class)\n   @ContextConfiguration(classes = AppConfig.class)\n   public class TestAppConfigJunit {\n   \n       @Autowired\n       ApplicationContext context;\n   \n       @Autowired\n       StderrLogger stderrLogger;\n   \n       @Autowired\n       ICalculator calculator;\n   \n       @Test\n       public void testStderrLogger() {\n           stderrLogger.log(\"hello on stderr\");\n       }\n   \n       @Autowired\n       @Qualifier(\"file\")\n       ILogger fileLogger;\n   \n       @Test\n       public void testFileLogger() {\n           fileLogger.log(\"hello on file\");\n       }\n   \n       @Test\n       public void testCalculator() {\n           assertEquals(30, calculator.add(10, 20));\n       }\n   \n   }\n   ```\n\n## Nouvelles implantations\n\nNotre première version de la calculatrice mélange du code métier (addition) et du code de trace. Ce n'est pas une très bonne idée. Proposez une nouvelle implantation de décoration de la calculatrice qui est construite sur deux paramètres :\n\n-  une référence vers une autre implantation de la calculatrice (qui ne fait aucune trace),\n-  une référence vers une implantation de la couche logger,\n\nCe décorateur va retransmettre les requêtes et y associer une trace.",
      "tags": [],
      "published": "23/10/2020",
      "authorId": "nicolas-desnoust",
      "category": "spring"
    },
    {
      "id": "KOm_V-T"
    }
  ],
  "categories": [
    {
      "id": "spring",
      "label": "Spring",
      "posts": [
        {
          "id": "2020-05-07-dev-api-rest-avec-spring",
          "title": "Développement d'une API REST avec Spring",
          "published": "05/07/2020",
          "authorId": "nicolas-desnoust",
          "tags": [
            "css",
            "footer",
            "responsive",
            "html"
          ]
        },
        {
          "id": "2020-23-10-introduction-spring",
          "title": "Introduction à Spring",
          "tags": [],
          "published": "23/10/2020",
          "authorId": "nicolas-desnoust"
        }
      ]
    },
    {
      "id": "css",
      "label": "CSS",
      "posts": [
        {
          "id": "2020-05-07-comment-rendre-son-footer-responsive",
          "title": "Comment rendre son footer responsive ?",
          "published": "05/07/2020",
          "authorId": "nicolas-desnoust",
          "tags": [
            "css",
            "footer",
            "responsive",
            "html"
          ]
        }
      ]
    },
    {
      "id": "vscode",
      "label": "Visual Studio Code",
      "posts": [
        {
          "id": "2020-08-10-setup-vscode",
          "title": "Setup de Visual Studio Code",
          "published": "08/10/2020",
          "authorId": "nicolas-desnoust",
          "tags": [
            "vscode",
            "extension",
            "police"
          ]
        }
      ]
    },
    {
      "id": "javascript",
      "label": "Javascript",
      "posts": []
    },
    {
      "id": "html",
      "label": "HTML",
      "posts": []
    },
    {
      "id": "typescript",
      "label": "Typescript",
      "posts": []
    }
  ]
}