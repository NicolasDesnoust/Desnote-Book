import { Post } from "../app/features/posts/model/post";

export const POSTS: Post[] = [
  {
    id: "2020-05-07-comment-rendre-son-footer-responsive",
    title: "Comment rendre son footer responsive ?",
    published: "05/07/2020",
    //author: "Nicolas Desnoust",
    content: "# Comment rendre son footer responsive ?\r\n\r\nVoici comment rendre un footer responsive uniquement en **CSS**.  le footer sera toujours plac\u00E9 en dessous du contenu de la page. Si cette derni\u00E8re d\u00E9borde il ne sera pas fix\u00E9 en bas et si le contenu est trop petit il se fixera en bas de la fen\u00EAtre du navigateur.\r\n\r\n## Code\r\n\r\n```css\r\nbody { display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; display: flex; flex-direction: column; min-height: 100vh; }\r\n```\r\n\r\n<ul class=\"nav nav-tabs\">\r\n  <li class=\"active nav-item\"><a data-toggle=\"tab\" class=\"nav-link active show\" href=\"#CSS\">CSS<\/a><\/li>\r\n  <li class=\"nav-item\"><a data-toggle=\"tab\" class=\"nav-link\" href=\"#HTML\">HTML<\/a><\/li>\r\n<\/ul>\r\n\r\n<div class=\"tab-content\">\r\n  <div name=\"CSS\" class=\"tab-pane fade in active show\">\r\n\r\n```css\r\nbody {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tmin-height: 100vh;\r\n}\r\n\r\n.contenu {\r\n\tflex-grow: 1;\r\n}\r\n```\r\n\r\n  <\/div>\r\n  <div name=\"HTML\" class=\"tab-pane fade\">\r\n    \r\n```html\r\n<!doctype html>\r\n\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"utf-8\">\r\n\r\n\t<title>Mon site<\/title>\r\n\t<meta name=\"description\" content=\"Description de mon site\">\r\n\t<meta name=\"author\" content=\"Moi-m\u00EAme\">\r\n\r\n\t<link rel=\"stylesheet\" href=\"style.css\">\r\n<\/head>\r\n\r\n<body>\r\n\t<header>\r\n\t\t\r\n\t<\/header>\r\n\t<section class=\"contenu\">\r\n\t\t<h1>Bienvenue sur mon site !<\/h1>\r\n\r\n\t\t<p>\r\n\t\t\tPour tester l'aspect responsive du footer, essayer \r\n\t\t\tde rajouter ou d'enlever du contenu ici et de \r\n\t\t\tredimensionner la f\u00EAnetre du navigateur.\r\n\t\t<\/p>\r\n\t<\/section>\r\n\t<footer>\r\n\t\t\r\n\t<\/footer>\r\n<\/body>\r\n<\/html>\r\n```\r\n\r\n<\/div>\r\n<\/div>",
    authorId: "nicolas-desnoust",
    tags: ["css", "footer", "responsive", "html"],
    category: "css"
  },
  {
    id: "2020-05-07-dev-api-rest-avec-spring",
    title: "DÃ©veloppement d'une API REST avec Spring",
    published: "05/07/2020",
    //author: "Nicolas Desnoust",
    content: "# D\u00E9veloppement d'une API REST avec Spring\r\n\r\n## Introduction\r\nCe mini-tutoriel permet d'explorer les possibilit\u00E9s de **Github Pages** et de la r\u00E9daction de tutoriels en **Markdown**. \r\nIl s'agit principalement de pr\u00E9senter comment r\u00E9aliser rapidement les fondements d'une **API REST** \u00E0 l'aide du framework **Spring**.\r\n> **Attention :** Ce tutoriel n'est actuellement pas complet. \r\n\r\n### Technologies\r\nVoici une liste exhaustive des technologies qui seront employ\u00E9es :\r\n\r\n - Spring REST\r\n - Spring Boot \/ Spring Initializr\r\n - Spring Data\r\n - Maven\r\n - Lombok\r\n - MySQL\r\n - JPA \/ Hibernate\r\n\r\n## Cr\u00E9ation du projet sur Spring Initializr\r\n\r\nLa premi\u00E8re \u00E9tape consite \u00E0 cr\u00E9er les sources du projet Maven en remplissant le formulaire de [Spring Initializr](https:\/\/start.spring.io).\r\n\r\nCe dernier devrait se pr\u00E9senter sous la forme suivante :\r\n\r\n![Aper\u00E7u de SPring Initializr](https:\/\/i.imgur.com\/SBl70J1.png)\r\n\r\n## Import sous Eclipse\r\n\r\n## Configuration de la base de donn\u00E9es\r\n\r\nLa configuration de la base de donn\u00E9es se r\u00E9alise dans le fichier `src\/main\/resources\/app.properties` :\r\n```properties\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.jpa.hibernate.show_sql=true\r\n\r\n# Configuration pour MySQL 8 (L'url, le username et le password sont \u00E0 changer).\r\nspring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect\r\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\nspring.datasource.url=jdbc:mysql:\/\/localhost:3306\/<nom-de-la-BDD>?serverTimezone=Europe\/Berlin\r\nspring.datasource.username=<identifiant>\r\nspring.datasource.password=<mot-de-passe>\r\n\r\n######### Configuration pour HSQLDB\r\n#spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\r\n#spring.datasource.driver-class-name=org.hsqldb.jdbcDriver\r\n#spring.datasource.url=jdbc:hsqldb:file:data\/ADM;shutdown=true;hsqldb.write_delay=false\r\n#spring.datasource.username=sa\r\n#spring.datasource.password=\r\n```\r\n\r\n## Coloration syntaxique en Java\r\n```java\r\npackage adm.entities.education;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.JoinColumn;\r\nimport javax.persistence.JoinTable;\r\nimport javax.persistence.ManyToMany;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.Table;\r\n\r\nimport lombok.AccessLevel;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonIgnore;\r\n\r\nimport adm.entities.AbstractEntity;\r\nimport adm.entities.association.Association;\r\nimport adm.entities.referentials.domain.Domain;\r\nimport adm.entities.referentials.organism.Organism;\r\nimport adm.entities.referentials.teachingmodality.TeachingModality;\r\nimport adm.entities.referentials.teachingsite.TeachingSite;\r\nimport adm.entities.referentials.typeofdegree.TypeOfDegree;\r\n\r\n@Entity\r\n@Table(name = \"FORMATION\")\r\n@Getter @Setter\r\n@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = true)\r\npublic class Education extends AbstractEntity {\r\n\r\n\t@Getter(AccessLevel.NONE) @Setter(AccessLevel.NONE)\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@ManyToOne\r\n\t@JoinColumn(name = \"CODE_TYPE_DIPLOME\", referencedColumnName = \"CODE\")\r\n\tprivate TypeOfDegree type;\r\n\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_DOM\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_DOMAINE\"))\r\n\tprivate Set<Domain> domains;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_ORG\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_ORGANISME\"))\r\n\tprivate Set<Organism> organisms;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_MOD\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_MODALITE\"))\r\n\tprivate Set<TeachingModality> modalities;\r\n\t\r\n\t@ManyToMany\r\n\t@JoinTable(\r\n\t  name = \"ASSOC_FOR_SIT\", \r\n\t  joinColumns = @JoinColumn(name = \"CODE_FORMATION\"), \r\n\t  inverseJoinColumns = @JoinColumn(name = \"CODE_SITE\"))\r\n\tprivate Set<TeachingSite> sites;\r\n\t\r\n\t@JsonIgnore\r\n\t@OneToMany(mappedBy = \"id.education\")\r\n\tprivate Collection<Association> associations;\r\n\t\r\n\tpublic Education() {\r\n\t\tdomains = new HashSet<Domain>();\r\n\t\torganisms = new HashSet<Organism>();\r\n\t\tmodalities = new HashSet<TeachingModality>();\r\n\t}\r\n}\r\n```\r\n## Coloration syntaxique en HTML\r\n```html\r\n<!doctype html>\r\n\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n\t\r\n    <title>The HTML5 Herald<\/title>\r\n    <meta name=\"description\" content=\"The HTML5 Herald\">\r\n    <meta name=\"author\" content=\"SitePoint\">\r\n\r\n    <link rel=\"stylesheet\" href=\"css\/styles.css?v=1.0\">\r\n<\/head>\r\n\r\n<body>\r\n    <script src=\"js\/scripts.js\"><\/script>\r\n<\/body>\r\n<\/html>\r\n```\r\n\r\nStackEdit stores your files in your browser, which means all your files are automatically saved locally and are accessible **offline!**\r\n\r\n## Create files and folders\r\n\r\nThe file explorer is accessible using the button in left corner of the navigation bar. You can create a new file by clicking the **New file** button in the file explorer. You can also create folders by clicking the **New folder** button.\r\n\r\n## Switch to another file\r\n\r\nAll your files and folders are presented as a tree in the file explorer. You can switch from one to another by clicking a file in the tree.\r\n\r\n## Rename a file\r\n\r\nYou can rename the current file by clicking the file name in the navigation bar or by clicking the **Rename** button in the file explorer.\r\n\r\n## Delete a file\r\n\r\nYou can delete the current file by clicking the **Remove** button in the file explorer. The file will be moved into the **Trash** folder and automatically deleted after 7 days of inactivity.\r\n\r\n## Export a file\r\n\r\nYou can export the current file by clicking **Export to disk** in the menu. You can choose to export the file as plain Markdown, as HTML using a Handlebars template or as a PDF.\r\n\r\n\r\n# Synchronization\r\n\r\nSynchronization is one of the biggest features of StackEdit. It enables you to synchronize any file in your workspace with other files stored in your **Google Drive**, your **Dropbox** and your **GitHub** accounts. This allows you to keep writing on other devices, collaborate with people you share the file with, integrate easily into your workflow... The synchronization mechanism takes place every minute in the background, downloading, merging, and uploading file modifications.\r\n\r\nThere are two types of synchronization and they can complement each other:\r\n\r\n- The workspace synchronization will sync all your files, folders and settings automatically. This will allow you to fetch your workspace on any other device.\r\n\t> To start syncing your workspace, just sign in with Google in the menu.\r\n\r\n- The file synchronization will keep one file of the workspace synced with one or multiple files in **Google Drive**, **Dropbox** or **GitHub**.\r\n\t> Before starting to sync files, you must link an account in the **Synchronize** sub-menu.\r\n\r\n## Open a file\r\n\r\nYou can open a file from **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Open from**. Once opened in the workspace, any modification in the file will be automatically synced.\r\n\r\n## Save a file\r\n\r\nYou can save any file of the workspace to **Google Drive**, **Dropbox** or **GitHub** by opening the **Synchronize** sub-menu and clicking **Save on**. Even if a file in the workspace is already synced, you can save it to another location. StackEdit can sync one file with multiple locations and accounts.\r\n\r\n## Synchronize a file\r\n\r\nOnce your file is linked to a synchronized location, StackEdit will periodically synchronize it by downloading\/uploading any modification. A merge will be performed if necessary and conflicts will be resolved.\r\n\r\nIf you just have modified your file and you want to force syncing, click the **Synchronize now** button in the navigation bar.\r\n\r\n> **Note:** The **Synchronize now** button is disabled if you have no file to synchronize.\r\n\r\n## Manage file synchronization\r\n\r\nSince one file can be synced with multiple locations, you can list and manage synchronized locations by clicking **File synchronization** in the **Synchronize** sub-menu. This allows you to list and remove synchronized locations that are linked to your file.\r\n\r\n\r\n# Publication\r\n\r\nPublishing in StackEdit makes it simple for you to publish online your files. Once you're happy with a file, you can publish it to different hosting platforms like **Blogger**, **Dropbox**, **Gist**, **GitHub**, **Google Drive**, **WordPress** and **Zendesk**. With [Handlebars templates](http:\/\/handlebarsjs.com\/), you have full control over what you export.\r\n\r\n> Before starting to publish, you must link an account in the **Publish** sub-menu.\r\n\r\n## Publish a File\r\n\r\nYou can publish your file by opening the **Publish** sub-menu and by clicking **Publish to**. For some locations, you can choose between the following formats:\r\n\r\n- Markdown: publish the Markdown text on a website that can interpret it (**GitHub** for instance),\r\n- HTML: publish the file converted to HTML via a Handlebars template (on a blog for example).\r\n\r\n## Update a publication\r\n\r\nAfter publishing, StackEdit keeps your file linked to that publication which makes it easy for you to re-publish it. Once you have modified your file and you want to update your publication, click on the **Publish now** button in the navigation bar.\r\n\r\n> **Note:** The **Publish now** button is disabled if your file has not been published yet.\r\n\r\n## Manage file publication\r\n\r\nSince one file can be published to multiple locations, you can list and manage publish locations by clicking **File publication** in the **Publish** sub-menu. This allows you to list and remove publication locations that are linked to your file.\r\n\r\n\r\n# Markdown extensions\r\n\r\nStackEdit extends the standard Markdown syntax by adding extra **Markdown extensions**, providing you with some nice features.\r\n\r\n> **ProTip:** You can disable any **Markdown extension** in the **File properties** dialog.\r\n\r\n\r\n## SmartyPants\r\n\r\nSmartyPants converts ASCII punctuation characters into \"smart\" typographic punctuation HTML entities. For example:\r\n\r\n|                |ASCII                          |HTML                         |\r\n|----------------|-------------------------------|-----------------------------|\r\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\r\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\r\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\r\n\r\n\r\n## KaTeX\r\n\r\nYou can render LaTeX mathematical expressions using [KaTeX](https:\/\/khan.github.io\/KaTeX\/):\r\n\r\nThe *Gamma function* satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral\r\n\r\n$$\r\n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\r\n$$\r\n\r\n> You can find more information about **LaTeX** mathematical expressions [here](http:\/\/meta.math.stackexchange.com\/questions\/5020\/mathjax-basic-tutorial-and-quick-reference).\r\n\r\n\r\n## UML diagrams\r\n\r\nYou can render UML diagrams using [Mermaid](https:\/\/mermaidjs.github.io\/). For example, this will produce a sequence diagram:\r\n\r\n```mermaid\r\nsequenceDiagram\r\nAlice ->> Bob: Hello Bob, how are you?\r\nBob-->>John: How about you John?\r\nBob--x Alice: I am good thanks!\r\nBob-x John: I am good thanks!\r\nNote right of John: Bob thinks a long<br\/>long time, so long<br\/>that the text does<br\/>not fit on a row.\r\n\r\nBob-->Alice: Checking with John...\r\nAlice->John: Yes... John, how are you?\r\n```\r\n\r\nAnd this will produce a flow chart:\r\n\r\n```mermaid\r\ngraph LR\r\nA[Square Rect] -- Link text --> B((Circle))\r\nA --> C(Round Rect)\r\nB --> D{Rhombus}\r\nC --> D\r\n```\r\n\r\n",
    authorId: "nicolas-desnoust",
    tags: ["css", "footer", "responsive", "html"],
    category: "spring"
  },
  {
    id: "2020-08-10-setup-vscode",
    title: "Setup de Visual Studio Code",
    published: "08/10/2020",
    //author: "Nicolas Desnoust",
    content: "# Setup de Visual Studio Code\r\n\r\n## Extensions utiles \u00E0 tout type de projet\r\n\r\n| Nom                       | Auteur     | Description                                                  |\r\n| ------------------------- | ---------- | ------------------------------------------------------------ |\r\n| Better comments           | Aaron Bond | Permet de cat\u00E9goriser les commentaires (alertes, questions, TODOs, commentaires importants, \u00E0 ignorer). |\r\n| Prettier - Code formatter | Prettier   | Formateur de code (n\u00E9cessaire pour les langages CSS\/SCSS non-support\u00E9s par d\u00E9faut). |\r\n\r\n## Installation d'une police avec ligatures\r\n\r\n1. **Installer les polices** \r\n\r\n   T\u00E9l\u00E9chargez la police Firacode ici : [**https:\/\/github.com\/tonsky\/FiraCode**](https:\/\/github.com\/tonsky\/FiraCode) et installez le contenu du dossier `ttf` sur votre syst\u00E8me d'exploitation. \r\n\r\n2. **Configurer Visual Studio Code**\r\n\r\n   Ouvrez les pr\u00E9f\u00E9rences utilisateur \u00E0 l'aide de la commande **Ctrl+Shift+P** et recherchez `Preferences: Open Settings (UI)`. \r\n\r\n   Pour activer la police pr\u00E9c\u00E9demment t\u00E9l\u00E9charg\u00E9e, dans l'\u00E9diteur des param\u00E8tres, cliquez sur `Font` sous l'onglet `Text Editor`. Dans le champ `Font Family` ajoutez `'Fira Code'` (avec les guillemets simple) en premier dans la liste. Cochez ensuite la case `Enable\/Disable font ligatures` sous `Font Ligatures` pour activer les ligatures.",
    authorId: "nicolas-desnoust",
    tags: ["vscode", "extension", "police"],
    category: "vscode"
  },
  {
    id: "2020-23-10-introduction-spring",
    title: "Introduction Ã  Spring",
    content: "# Une (petite) introduction \u00E0 Spring\r\n\r\n## Introduction\r\n\r\nLe framework [Spring](http:\/\/www.springframework.org\/) est une boite \u00E0 outils tr\u00E8s riche permettant de structurer, d'am\u00E9liorer et de simplifier l'\u00E9criture d'application JEE. Spring est organis\u00E9 en module :\r\n\r\n- Gestion des instances de classes (JavaBean et\/ou m\u00E9tier),\r\n- Programmation orient\u00E9e Aspect,\r\n- Mod\u00E8le MVC et outils pour les applications WEB,\r\n- Outils pour la DAO (JDBC),\r\n- Outils pour les ORM (Hibernate, iBatis, ...),\r\n- Outils pour les applications JEE (JMX, JMA, JCA, EJB, ...).\r\n\r\n[Plus d'informations ici](https:\/\/docs.spring.io\/spring\/docs\/5.2.x\/spring-framework-reference\/overview.html).\r\n\r\n## Programmation par contrat\r\n\r\nTravail \u00E0 faire :\r\n\r\n- Lancez Eclipse JEE (commande eclipse). Si la commande n'est pas disponible, t\u00E9l\u00E9chargez directement [Eclipse JEE](http:\/\/jean-luc.massat.perso.luminy.univ-amu.fr\/ens\/jee-pour-M2\/ress\/).\r\n- Pr\u00E9parez un projet Java standard pour tester les exemples pr\u00E9sent\u00E9s ci-dessous.\r\n\r\n### Principe\r\n\r\nLa programmation par contrat consiste \u00E0 s\u00E9parer la sp\u00E9cification d'une couche logicielle (aussi appel\u00E9e service) de sa r\u00E9alisation. La sp\u00E9cification donne lieu \u00E0 la cr\u00E9ation d'une interface et la r\u00E9alisation fournit une classe qui implante cette interface. Ce ne sont pas n\u00E9cessairement les m\u00EAmes personnes qui d\u00E9veloppent l'interface et son implantation. On peut \u00E9galement remarquer que la phase de r\u00E9alisation peut produire plusieurs implantations diff\u00E9rentes d'une m\u00EAme interface. Le choix entre ces implantations est r\u00E9alis\u00E9 \u00E0 l'int\u00E9gration entre les couches. Les objectifs de cette approche :\r\n\r\n- **R\u00E9duire les d\u00E9pendances.**\r\n\r\n Les classes d'implantation ne se connaissent pas. Elles dialoguent au moyen des interfaces. De ce fait, on peut facilement changer un implantation contre une autre sans avoir \u00E0 mettre \u00E0 jour la totalit\u00E9 du logiciel.\r\n\r\n- **Faciliter les tests.**\r\n\r\n Chaque couche logicielle ayant une sp\u00E9cification claire, il est facile de lui associer un jeu de tests utilisable quelque soit la nature de l'implantation.\r\n\r\n- **Simplifier le code.**\r\n\r\n Dans certains cas de figure, le code d'une m\u00E9thode est une suite de consid\u00E9rations sans liaison directe entre-elles. La programmation par contrat va faciliter la construction d'implantations fa\u00E7ade qui se chargent chacune d'une partie du travail.\r\n\r\n- **Organiser le d\u00E9veloppement.**\r\n\r\n### Sp\u00E9cifier un service logiciel\r\n\r\nPrenons un exemple pour \u00E9clairer ces principes. Nous avons besoin dans nos applications de pouvoir tracer un certain nombre d'\u00E9v\u00E8nements. Nous allons donc cr\u00E9er un service de trace (un *logger* en anglais). Ce service est sp\u00E9cifi\u00E9 par l'interface ci-dessous :\r\n\r\n```java\r\npackage myapp.services;\r\n\r\npublic interface ILogger {\r\n\r\n    default void log(String message) {  };\r\n\r\n}\r\n```\r\n\r\n### Une premi\u00E8re implantation\r\n\r\nPour utiliser ce service, nous avons besoin d'une classe qui implante ce service. Il existe plusieurs mani\u00E8res de faire. Nous allons, dans une premier temps, envoyer les messages de trace sur la console de sortie d'erreur standard :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport java.util.Date;\r\n\r\nimport myapp.services.ILogger;\r\n\r\npublic class StderrLogger implements ILogger {\r\n\r\n    public void start() {\r\n        System.err.println(\"Start \" + this);\r\n    }\r\n\r\n    public void stop() {\r\n        System.err.println(\"Stop \" + this);\r\n    }\r\n\r\n    @Override\r\n    public void log(String message) {\r\n        System.err.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\r\n    }\r\n\r\n}\r\n```\r\n\r\nLes m\u00E9thodes start et stop correspondent \u00E0 la phase de d\u00E9marrage et de terminaison du service. Nous retrouverons ces m\u00E9thodes dans toutes les implantations (m\u00EAme si elles sont vides).\r\n\r\n A propos des packages. Vous pouvez noter dans cet exemple que l'interface est dans un package et que la classe d'implantation est dans un autre. Dans un cas r\u00E9el, la sp\u00E9cification d'un service peut \u00EAtre compos\u00E9 de plusieurs interfaces accompagn\u00E9es de javaBeans ou de classes d'exception. L'implantation de ce service peut \u00E9galement contenir plusieurs classes ce qui justifie clairement l'utilisation de plusieurs packages.\r\n\r\nNous pouvons maintenant utiliser ce service. Pour ce faire, nous allons construire une classe de test unitaire (avec JUnit 5 \u00E0 ajouter dans le buildpath de votre projet Eclipse) :\r\n\r\n```java\r\npackage myapp.tests;\r\n\r\nimport org.junit.jupiter.api.AfterEach;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport myapp.imp.StderrLogger;\r\nimport myapp.services.ILogger;\r\n\r\npublic class TestLoggerServices {\r\n\r\n    @BeforeEach\r\n    public void beforeEachTest() {\r\n        System.err.println(\"====================\");\r\n    }\r\n\r\n    @AfterEach\r\n    public void afterEachTest() {\r\n    }\r\n\r\n    \/\/ use a logger\r\n    void use(ILogger logger) {\r\n        logger.log(\"Voila le r\u00E9sultat = hello\");\r\n    }\r\n\r\n    \/\/ Test StderrLogger\r\n    @Test\r\n    public void testStderrLogger() {\r\n        \/\/ create the service\r\n        var logger = new StderrLogger();\r\n        \/\/ start the service\r\n        logger.start();\r\n        \/\/ use the service\r\n        use(logger);\r\n        \/\/ stop the service\r\n        logger.stop();\r\n    }\r\n\r\n}\r\n```\r\n\r\nA ce stade, nous pouvons remarquer que :\r\n\r\n Les utilisateurs (la m\u00E9thode use ci-dessus) n'ont aucune connaissance des d\u00E9tails de l'implantation. Seule l'interface est utilis\u00E9e.\r\n Il existe tout de m\u00EAme une d\u00E9pendance puisque le nom de la classe d'implantation appara\u00EEt en clair dans le code de l'utilisateur (m\u00E9thode testStderrLogger).\r\n L'int\u00E9grateur (methode testStderrLogger) est responsable du respect du contrat (on appelle d'abord start, puis on utilise, puis on appelle stop).\r\n\r\n### Une deuxi\u00E8me implantation\r\n\r\nNous pouvons aussi donner une deuxi\u00E8me implantation qui stocke les traces dans un fichier :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.Date;\r\n\r\nimport myapp.services.ILogger;\r\n\r\npublic class FileLogger implements ILogger {\r\n\r\n    \/\/ parameter: the writer\r\n    private final PrintWriter writer;\r\n\r\n    public FileLogger(String fileName) {\r\n        try {\r\n            this.writer = new PrintWriter(new FileOutputStream(fileName, true));\r\n        } catch (FileNotFoundException e) {\r\n            throw new IllegalArgumentException(\"bad fileName\");\r\n        }\r\n    }\r\n\r\n    public void start() {\r\n        System.err.println(\"Start \" + this);\r\n    }\r\n\r\n    public void stop() {\r\n        writer.close();\r\n        System.err.println(\"Stop \" + this);\r\n    }\r\n\r\n    @Override\r\n    public void log(String message) {\r\n        writer.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\r\n    }\r\n\r\n}\r\n```\r\n\r\nCette nouvelle implantation a absolument besoin d'un param\u00E8tre (le nom du fichier) pour \u00EAtre fonctionnelle. La solution retenue est la plus simple : ajouter un argument au constructeur. Nous remarquons que de ce fait, la m\u00E9thode start n'a plus vraiment d'int\u00E9r\u00EAt.\r\n\r\nOn remarque que le code d'int\u00E9gration est tr\u00E8s peu modifi\u00E9 (une ligne), alors que le fonctionnement est totalement diff\u00E9rent. On remarque \u00E9galement que le code d'utilisation (m\u00E9thode use) n'est pas alt\u00E9r\u00E9. Les modifications portent uniquement sur le code d'int\u00E9gration :\r\n\r\n```java\r\n@Test\r\npublic void testFileLogger() {\r\n    var logger = new FileLogger(\"\/tmp\/myapp.log\");\r\n    logger.start();\r\n    use(logger);\r\n    logger.stop();\r\n}\r\n```\r\n\r\n### Une troisi\u00E8me implantation\r\n\r\nLa plupart des classes d'implantation ont besoin de param\u00E8tres pour assurer leur service. Le choix de placer ces param\u00E8tres en argument du constructeur pose plusieurs probl\u00E8mes :\r\n\r\n-  La classe obtenue n'est pas un javaBean (pas de constructeur vide). C'est particuli\u00E8rement g\u00EAnant car l'int\u00E9r\u00EAt de ces composants \u00E9l\u00E9mentaires est tr\u00E8s important.\r\n-  Les param\u00E8tres du service sont fix\u00E9s \u00E0 sa cr\u00E9ation (par le constructeur). Il n'est donc pas possible de les changer en cours de route, voir m\u00EAme d'envisager un recyclage du service (changement des param\u00E8tres et nouvelle initialisation).\r\n-  Si nous avons beaucoup de param\u00E8tres, le constructeur est difficile \u00E0 utiliser.\r\n-  Il n'est pas possible de pr\u00E9voir des valeurs par d\u00E9faut pour certains param\u00E8tres.\r\n\r\nNous allons donc introduire une nouvelle solution au probl\u00E8me des param\u00E8tres : les param\u00E8tres vont \u00EAtre cod\u00E9s comme des propri\u00E9t\u00E9s de la classe d'implantation et la m\u00E9thode start devra les utiliser pour initialiser le service. Nous obtenons donc cette nouvelle version :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.Date;\r\n\r\nimport myapp.services.ILogger;\r\n\r\npublic class BeanFileLogger implements ILogger {\r\n\r\n    \/\/ parameter: writer name\r\n    private String fileName;\r\n\r\n    \/\/ property: writer\r\n    private PrintWriter writer;\r\n\r\n    \/\/ start service\r\n    public void start() {\r\n        if (fileName == null) {\r\n            throw new IllegalStateException(\"no fileName\");\r\n        }\r\n        try {\r\n            OutputStream os = new FileOutputStream(fileName, true);\r\n            this.writer = new PrintWriter(os);\r\n        } catch (FileNotFoundException e) {\r\n            throw new IllegalStateException(\"bad fileName\");\r\n        }\r\n        System.err.println(\"Start \" + this);\r\n    }\r\n\r\n    \/\/ stop service\r\n    public void stop() {\r\n        writer.close();\r\n        System.err.println(\"Stop \" + this);\r\n    }\r\n\r\n    @Override\r\n    public void log(String message) {\r\n        writer.printf(\"%tF %1$tR | %s\\n\", new Date(), message);\r\n    }\r\n\r\n    public String getFileName() {\r\n        return fileName;\r\n    }\r\n\r\n    public void setFileName(String fileName) {\r\n        this.fileName = fileName;\r\n    }\r\n\r\n}\r\n```\r\n\r\nLe code d'int\u00E9gration a maintenant la responsabilit\u00E9 de fixer les param\u00E8tres du service avant d'appeler la m\u00E9thode d'initialisation. Cette solution est plus simple et plus syst\u00E9matique quand le nombre de param\u00E8tres est important :\r\n\r\n```java\r\n@Test\r\npublic void testBeanFileLogger() {\r\n    \/\/ create the service\r\n    var logger = new BeanFileLogger();\r\n    \/\/ set parameter\r\n    logger.setFileName(\"\/tmp\/myapp.log\");\r\n    \/\/ start\r\n    logger.start();\r\n    \/\/ use\r\n    use(logger);\r\n    \/\/ stop\r\n    logger.stop();\r\n}\r\n```\r\n\r\nTravail \u00E0 faire : En donnant une valeur par d\u00E9faut au param\u00E8tre de la classe BeanFileLogger nous pouvons rendre optionnelle la phase de param\u00E9trage. mettez en oeuvre et testez ce principe.\r\n\r\n## Injection des d\u00E9pendances\r\n\r\nL'injection des d\u00E9pendances traite le d\u00E9licat probl\u00E8me de la communication et de la d\u00E9pendance entre services logiciels. Prenons l'exemple d'une classe m\u00E9tier :\r\n\r\n```java\r\npackage myapp.services;\r\n\r\npublic interface ICalculator {\r\n\r\n    int add(int a, int b);\r\n\r\n}\r\n```\r\n\r\nConstruisons maintenant une implantation de ce service qui g\u00E9n\u00E8re une trace apr\u00E8s chaque appel d'une m\u00E9thode m\u00E9tier. Cette implantation a donc besoin d'une couche logger pour s'ex\u00E9cuter correctement. Nous pourrions envisager de placer dans cette implantation la propri\u00E9t\u00E9s suivante :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport myapp.services.ICalculator;\r\nimport myapp.services.ILogger;\r\n\r\npublic class SimpleCalculator implements ICalculator {\r\n\r\n    private ILogger logger = new myapp.imp.StderrLogger();\r\n\r\n    ...\r\n}\r\n```\r\n\r\nCette solution pose deux probl\u00E8mes :\r\n\r\n1. Une d\u00E9pendance directe vient d'\u00EAtre introduite entre cette implantation de la calculatrice et une implantation particuli\u00E8re de la couche logger. Cette d\u00E9pendance est regrettable car inutile. La calculatrice doit utiliser l'interface ILogger et pas une implantation.\r\n2. Si nous avions choisi une couche de trace ayant besoin d'un param\u00E8tre (comme celle vue pr\u00E9c\u00E9demment), nous aurions sans doute d\u00FB inclure ce param\u00E8tre (le fichier de sortie) comme un param\u00E8tre de la calculatrice. En d'autres termes, les param\u00E8tres d'une couche A doivent inclure tous les param\u00E8tres des couches utilis\u00E9es par A.\r\n\r\nPour \u00E9viter ces probl\u00E8mes, nous allons simplement introduire dans l'implantation de la calculatrice un param\u00E8tre faisant r\u00E9f\u00E9rence \u00E0 une implantation de la couche logger. De ce fait, les deux implantations resteront ind\u00E9pendantes l'une de l'autre. Le seul point de contact sera l'interface ILogger :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport myapp.services.ICalculator;\r\nimport myapp.services.ILogger;\r\n\r\npublic class SimpleCalculator implements ICalculator {\r\n\r\n    private ILogger logger;\r\n\r\n    public void start() {\r\n        if (logger == null) {\r\n            throw new IllegalStateException(\"null logger\");\r\n        }\r\n        System.err.println(\"Start \" + this);\r\n    }\r\n\r\n    public void stop() {\r\n        System.err.println(\"Stop \" + this);\r\n    }\r\n\r\n    public int add(int a, int b) {\r\n        logger.log(String.format(\"add(%d,%d)\", a, b));\r\n        return (a + b);\r\n    }\r\n\r\n    public ILogger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    public void setLogger(ILogger logger) {\r\n        this.logger = logger;\r\n    }\r\n\r\n}\r\n```\r\n\r\nLa phase d'int\u00E9gration devient plus d\u00E9licate puisqu'il faut cr\u00E9er et initialiser deux couches logicielles (il faut ajouter une clause import pour assertEquals) :\r\n\r\n```java\r\nvoid use(ICalculator calc) {\r\n    assertEquals(300, calc.add(100, 200));\r\n}\r\n\r\n@Test\r\npublic void testCalculorAndStderrLogger() {\r\n    \/\/ create and start the logger service (on stderr)\r\n    var logger = new StderrLogger();\r\n    logger.start();\r\n    \/\/ create, inject and start the calculator service\r\n    var calculator = new SimpleCalculator();\r\n    calculator.setLogger(logger);\r\n    calculator.start();\r\n    \/\/ use the calculator service\r\n    use(calculator);\r\n    \/\/ stop the calculator service\r\n    calculator.stop();\r\n    \/\/ stop the logger service\r\n    logger.stop();\r\n}\r\n```\r\n\r\nNous pouvons tr\u00E8s facilement et sans modifier la couche m\u00E9tier changer la politique de trace en utilisant un fichier. Il suffit de changer les quatre premi\u00E8res lignes du code d'int\u00E9gration :\r\n\r\n```java\r\n\/\/ create file logger\r\nvar logger = new BeanFileLogger();\r\nlogger.setFileName(\"\/tmp\/myapp.log\");\r\nlogger.start();\r\n```\r\n\r\nNous venons de mettre en oeuvre le principe de l'injection de d\u00E9pendances. C'est la partie int\u00E9gration qui se charge d'injecter dans la couche m\u00E9tier la r\u00E9f\u00E9rence vers la couche logger. Initialiser une application revient \u00E0 cr\u00E9er les couches logicielles, injecter les d\u00E9pendances et appeler les m\u00E9thodes d'initialisation.\r\n\r\n## Gestion des beans par Spring\r\n\r\nLa cr\u00E9ation des instances de javaBeans, l'injection des d\u00E9pendances et le nommage des instances sont le coeur du framework Spring. Nous allons donc reprendre ces exemples en utilisant les outils fournis par Spring.\r\n\r\n### Installation de Spring\r\n\r\nPour int\u00E9grer \u00E0 votre projet le framework Spring et ses d\u00E9pendances, nous allons utiliser Maven :\r\n\r\n-  Ajoutez Maven \u00E0 votre projet : S\u00E9lectionnez votre projet \/ Bouton-droit \/ Configure \/ Convert to Maven Project. Vous devez \u00E0 cette \u00E9tape donner une num\u00E9ro de version \u00E0 votre projet. Laissez les valeurs par d\u00E9faut.\r\n-  L'action pr\u00E9c\u00E9dente a g\u00E9n\u00E9r\u00E9 un fichier pom.xml qui est le coeur de la configuration de Maven. L'\u00E9diteur de ce fichier doit \u00EAtre ouvert. Ajoutez la d\u00E9pendance ci-dessous (tir\u00E9e de la page de chargement du site WEB de Spring):\r\n\r\n```xml\r\n<dependencies>\r\n    <!-- pour utiliser Spring -->\r\n    <dependency>\r\n        <groupId>org.springframework<\/groupId>\r\n        <artifactId>spring-context<\/artifactId>\r\n        <version>5.2.4.RELEASE<\/version>\r\n    <\/dependency>\r\n    \r\n    <!-- pour utiliser la partie test de Spring -->\r\n    <dependency>\r\n        <groupId>org.springframework<\/groupId>\r\n        <artifactId>spring-test<\/artifactId>\r\n        <version>5.2.4.RELEASE<\/version>\r\n    <\/dependency>\r\n    \r\n    <!-- pour les annotations (\u00E0 partir de java 10) -->\r\n    <dependency>\r\n        <groupId>javax.annotation<\/groupId>\r\n        <artifactId>javax.annotation-api<\/artifactId>\r\n        <version>1.3.2<\/version>\r\n    <\/dependency>\r\n<\/dependencies>\r\n```\r\n\r\n-  Vous devez avoir dans votre projet un r\u00E9pertoire Maven dependencies qui liste les .jar de Spring.\r\n-  Pr\u00E9parez, dans un navigateur, un onglet vers la la documentation Spring.\r\n\r\n### Callbacks par annotations\r\n\r\nNous allons commencer par utiliser des annotations standards (non li\u00E9es directement \u00E0 Spring) pour indiquer dans nos classes les m\u00E9thodes d'initialisation (@PostConstruct) et de terminaison (@PreDestroy). Ces m\u00E9thodes seront automatiquement appel\u00E9es par Spring.\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport javax.annotation.PostConstruct;\r\nimport javax.annotation.PreDestroy;\r\n...\r\n\r\n    public class StderrLogger implements ILogger {\r\n\r\n        ...\r\n\r\n            \/\/ start service\r\n            @PostConstruct\r\n            public void start() {\r\n            ...\r\n        }\r\n\r\n        \/\/ stop service\r\n        @PreDestroy\r\n        public void stop() {\r\n            ...\r\n        }\r\n\r\n        ...\r\n\r\n    }\r\n```\r\n\r\n\u00C0 faire : ajoutez ces annotations \u00E0 SimpleCalculator.java.\r\n\r\n### Cr\u00E9er et utiliser des javaBeans\r\n\r\nDans Spring, la d\u00E9finition des javaBeans, leurs noms et leurs param\u00E8tres sont d\u00E9finis dans un fichier de configuration au format XML. Une fois ce fichier pr\u00E9par\u00E9, Spring est capable de cr\u00E9er les classes de service en effectuant les injections de d\u00E9pendances et les initialisations n\u00E9cessaires.\r\n\r\nPr\u00E9parez dans votre projet le fichier XML config.xml suivant dans le r\u00E9pertoire src :\r\n\r\n```xml\r\n<beans xmlns=\"http:\/\/www.springframework.org\/schema\/beans\"\r\n       xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\r\n       xmlns:context=\"http:\/\/www.springframework.org\/schema\/context\"\r\n       xsi:schemaLocation=\"http:\/\/www.springframework.org\/schema\/beans\r\n                           http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd\r\n                           http:\/\/www.springframework.org\/schema\/context\r\n                           http:\/\/www.springframework.org\/schema\/context\/spring-context.xsd\">\r\n\r\n    <!-- pour utiliser les annotations -->\r\n    <context:annotation-config \/>\r\n\r\n    <!-- logger sur Stderr (logger par d\u00E9faut)-->\r\n    <bean id=\"stderrLogger\" class=\"myapp.imp.StderrLogger\" primary=\"true\" \/>\r\n\r\n    <!-- logger sur \/tmp\/myapp.log -->\r\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\r\n        <property name=\"fileName\">\r\n            <value>\/tmp\/myapp.log<\/value>\r\n        <\/property>\r\n    <\/bean>\r\n\r\n    <!-- calculatrice qui trace sur Stderr -->\r\n    <bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\">\r\n        <property name=\"logger\" ref=\"stderrLogger\" \/>\r\n    <\/bean>\r\n\r\n<\/beans>\r\n```\r\n\r\nNous allons pouvoir utiliser Spring pour exploiter la calculatrice et le logger :\r\n\r\n```java\r\npackage myapp.tests;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\n\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\nimport myapp.services.ICalculator;\r\nimport myapp.services.ILogger;\r\n\r\npublic class TestSpring {\r\n\r\n    @BeforeEach\r\n    public void beforeEachTest() {\r\n        System.err.println(\"====================\");\r\n    }\r\n\r\n    void use(ILogger logger) {\r\n        logger.log(\"Voila le r\u00E9sultat\");\r\n    }\r\n\r\n    void use(ICalculator calc) {\r\n        assertEquals(300, calc.add(100, 200));\r\n    }\r\n\r\n    @Test\r\n    public void testStderrLogger() {\r\n        System.err.println(\"+++ StderrLogger\");\r\n        var conf = \"config.xml\";\r\n\r\n        \/\/ create a context and find beans\r\n        try (var ctx = new ClassPathXmlApplicationContext(conf);) {\r\n            var logger = ctx.getBean(\"stderrLogger\", ILogger.class);\r\n            use(logger);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testCalculatorWithLogger() {\r\n        System.err.println(\"+++ CalculatorWithLogger\");\r\n        var conf = \"config.xml\";\r\n\r\n        \/\/ create a context and find beans\r\n        try (var ctx = new ClassPathXmlApplicationContext(conf);) {\r\n            var calc = ctx.getBean(\"calculator\", ICalculator.class);\r\n            use(calc);\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nSi nous voulons changer le logger de la calculatrice, il n'est pas n\u00E9cessaire de modifier notre programme. Il suffit de changer le fichier XML :\r\n\r\n```xml\r\n<!-- calculatrice qui trace sur un fichier -->\r\n<bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\">\r\n    <property name=\"logger\" ref=\"fileLogger\" \/>\r\n<\/bean>\r\n```\r\n\r\nTestez cette nouvelle version.\r\n\r\nNous pouvons m\u00EAme avoir deux versions de la calculatrice en fonction de la trace choisie.\r\n\r\nVous pouvez parcourir avec profit les trois premi\u00E8res sections de ce chapitre.\r\n\r\n## Utilisez les annotations de Spring\r\n\r\nDepuis java 1.5, le framework Spring est \u00E9galement capable de d\u00E9crire la configuration des beans par un jeu d'annotations. Nous allons pouvoir d\u00E9crire l'injection de d\u00E9pendances et la cr\u00E9ation des instances de mani\u00E8re d\u00E9clarative et laisser le soin \u00E0 Spring de r\u00E9aliser les op\u00E9rations.\r\n\r\n### Injection par annotation\r\n\r\nDans la classe SimpleCalculator, indiquez par une annotation (@Autowired) que vous souhaitez l'injection d'un classe logger :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n...\r\n\r\n    public class SimpleCalculator implements ICalculator {\r\n\r\n        ...\r\n\r\n            public ILogger getLogger() {\r\n            return logger;\r\n        }\r\n\r\n        @Autowired\r\n        public void setLogger(ILogger logger) {\r\n            this.logger = logger;\r\n        }\r\n\r\n    }\r\n```\r\n\r\nLe code XML est maintenant simplifi\u00E9 :\r\n\r\n```xml\r\n<beans xmlns=\"http:\/\/www.springframework.org\/schema\/beans\"\r\n       xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\r\n       xmlns:context=\"http:\/\/www.springframework.org\/schema\/context\"\r\n       xsi:schemaLocation=\"http:\/\/www.springframework.org\/schema\/beans\r\n                           http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd\r\n                           http:\/\/www.springframework.org\/schema\/context\r\n                           http:\/\/www.springframework.org\/schema\/context\/spring-context.xsd\">\r\n\r\n    <!-- pour utiliser les annotations -->\r\n    <context:annotation-config \/>\r\n\r\n    <!-- logger sur Stderr (logger par d\u00E9faut)-->\r\n    <bean id=\"stderrLogger\" class=\"myapp.imp.StderrLogger\" primary=\"true\" \/>\r\n\r\n    <!-- logger sur \/tmp\/myapp.log -->\r\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\r\n        <property name=\"fileName\">\r\n            <value>\/tmp\/myapp.log<\/value>\r\n        <\/property>\r\n    <\/bean>\r\n\r\n    <!-- calculatrice qui trace sur Stderr -->\r\n    <bean id=\"calculator\" class=\"myapp.imp.SimpleCalculator\" \/>\r\n\r\n<\/beans>\r\n```\r\n\r\nL'injection, c'est \u00E0 dire la liaison entre la classe utilis\u00E9e et la classe utilisatrice, se r\u00E9alise sur la base du type (ici l'interface ILogger) et du nom (ici \u00AB logger \u00BB).\r\n\r\nNote : Il ya deux versions du logger (stderrLogger et fileLogger). L'attribut primary indique le service choisi par d\u00E9faut.\r\n\r\n### D\u00E9clarer les services par annotation\r\n\r\nNous pouvons \u00E9galement d\u00E9clarer une classe comme \u00E9tant un service. Cette annotation va permettre de l'instancier automatiquement en cas de besoin. Appliquons ce principe sur la classe StderrLogger (et faites la m\u00EAme chose sur SimpleCalculator) :\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\n...\r\n    \r\nimport org.springframework.context.annotation.Primary;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service(\"stderrLogger\")\r\n@Primary\r\npublic class StderrLogger implements ILogger {\r\n\r\n    ...\r\n\r\n}\r\n```\r\n\r\nLe code XML devient maintenant beaucoup plus simple :\r\n\r\n```xml\r\n<beans xmlns=\"http:\/\/www.springframework.org\/schema\/beans\"\r\n       xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\r\n       xmlns:context=\"http:\/\/www.springframework.org\/schema\/context\"\r\n       xsi:schemaLocation=\"http:\/\/www.springframework.org\/schema\/beans\r\n                           http:\/\/www.springframework.org\/schema\/beans\/spring-beans.xsd\r\n                           http:\/\/www.springframework.org\/schema\/context\r\n                           http:\/\/www.springframework.org\/schema\/context\/spring-context.xsd\">\r\n\r\n    <!-- pour utiliser les annotations -->\r\n    <context:annotation-config \/>\r\n\r\n    <!-- pour trouver les classes de service -->\r\n    <context:component-scan base-package=\"myapp.imp\" \/>\r\n\r\n    <!-- logger sur \/tmp\/myapp.log -->\r\n    <bean id=\"fileLogger\" class=\"myapp.imp.BeanFileLogger\">\r\n        <property name=\"fileName\">\r\n            <value>\/tmp\/myapp.log<\/value>\r\n        <\/property>\r\n    <\/bean>\r\n\r\n<\/beans>\r\n```\r\n\r\n### Contr\u00F4ler les implantations choisies\r\n\r\nIl existe souvent plusieurs implantations concurrentes d'un m\u00EAme service et nous avons besoin de contr\u00F4ler le choix lors des injections.\r\n\r\n-  Supprimez l'annotation @Primary de StderrLogger.\r\n-  \u00C0 ce stade vous devez obtenir une erreur indiquant que deux classes sont disponibles pour l'interface ILogger.\r\n-  Vous pouvez d'une part ajouter une clause @Qualifier \u00E0 la classe StderrLogger:\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\n...\r\n\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\n@Qualifier(\"test\")\r\npublic class StderrLogger implements ILogger {\r\n\r\n    ...\r\n\r\n}\r\n```\r\n\r\n et ajouter la m\u00EAme annotation dans la classe SimpleCalculator:\r\n\r\n```java\r\npackage myapp.imp;\r\n\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n...\r\n\r\n    public class SimpleCalculator implements ICalculator {\r\n\r\n        ...\r\n\r\n            @Autowired\r\n            @Qualifier(\"test\")\r\n            public void setLogger(ILogger logger) {\r\n            this.logger = logger;\r\n        }\r\n\r\n    }\r\n```\r\n\r\nD\u00E9couvrez d'autres possibilit\u00E9s de @Qualifier.\r\n\r\nD\u00E9couvrez d'autres possibilit\u00E9s des annotations.\r\n\r\n## Int\u00E9gration JUnit \/ Spring\r\n\r\nAfin de rendre nos tests unitaires plus simples, nous pouvons utiliser une meilleure int\u00E9gration de Spring et de Junit et injecter des beans directement dans la classe de test :\r\n\r\n```java\r\npackage myapp.tests;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\n\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\n\r\nimport myapp.services.ICalculator;\r\nimport myapp.services.ILogger;\r\n\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(locations = \"\/config.xml\")\r\npublic class TestSpringJUnitIntegration {\r\n\r\n    @Autowired\r\n    ILogger logger;\r\n\r\n    @Autowired\r\n    ICalculator calc;\r\n\r\n    @BeforeEach\r\n    public void beforeEachTest() {\r\n        System.err.println(\"====================\");\r\n    }\r\n\r\n    void use(ILogger logger) {\r\n        logger.log(\"Voila le r\u00E9sultat\");\r\n    }\r\n\r\n    void use(ICalculator calc) {\r\n        assertEquals(300, calc.add(100, 200));\r\n    }\r\n\r\n    @Test\r\n    public void testStderrLogger() {\r\n        System.err.println(\"+++ StderrLogger\");\r\n        use(logger);\r\n    }\r\n\r\n    @Test\r\n    public void testCalculatorWithLogger() {\r\n        use(calc);\r\n    }\r\n\r\n}\r\n```\r\n\r\n## Configurer en Java\r\n\r\nNous avons la possibilit\u00E9, depuis la version 3, de configurer Spring en utilisant une classe et des annotations. D\u00E9couvrez cette technique et cr\u00E9ez de nouvelles versions de la couche BeanFileLogger.\r\n\r\n1. D\u00E9butez par la cr\u00E9ation d'une classe de configuration. Elle remplace compl\u00E8tement le fichier XML et, via des m\u00E9thodes annot\u00E9es @Bean, propose la cr\u00E9ation de services :\r\n\r\n   ```java\r\n   package myapp.tests;\r\n   \r\n   import org.springframework.beans.factory.annotation.Qualifier;\r\n   import org.springframework.context.annotation.Bean;\r\n   import org.springframework.context.annotation.ComponentScan;\r\n   import org.springframework.stereotype.Component;\r\n   \r\n   import myapp.imp.BeanFileLogger;\r\n   import myapp.services.ILogger;\r\n   \r\n   @Component\r\n   @ComponentScan(\"myapp.imp\")\r\n   public class AppConfig {\r\n   \r\n       @Bean\r\n       @Qualifier(\"file\")\r\n       public ILogger myLogger() {\r\n           var logger = new BeanFileLogger();\r\n           logger.setFileName(\"\/tmp\/essai.log\");\r\n           System.err.println(\"Production de \" + logger);\r\n           return logger;\r\n       }\r\n   \r\n   }\r\n   ```\r\n\r\n2. Nous pouvons cr\u00E9er un simple test pour construire un contexte et r\u00E9cup\u00E9rer une instance :\r\n\r\n   ```java\r\n   package myapp.tests;\r\n   \r\n   import org.junit.jupiter.api.Test;\r\n   import org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\n   \r\n   import myapp.imp.StderrLogger;\r\n   import myapp.services.ILogger;\r\n   \r\n   public class TestAppConfig {\r\n   \r\n       \/*\r\n        * Construction d'un contexte classique\r\n        *\/\r\n       @Test\r\n       public void testStderrLogger() {\r\n           try (var c = new AnnotationConfigApplicationContext(AppConfig.class)) {\r\n               var logger = c.getBean(StderrLogger.class);\r\n               logger.log(\"hello on stderr\");\r\n           }\r\n       }\r\n   }\r\n   ```\r\n\r\n3. Nous pouvons \u00E9galement utiliser l'int\u00E9gration Spring\/Junit pour r\u00E9cup\u00E9rer et tester plusieurs services :\r\n\r\n   ```java\r\n   package myapp.tests;\r\n   \r\n   import static org.junit.jupiter.api.Assertions.assertEquals;\r\n   \r\n   import org.junit.jupiter.api.Test;\r\n   import org.junit.jupiter.api.extension.ExtendWith;\r\n   \r\n   import org.springframework.beans.factory.annotation.Autowired;\r\n   import org.springframework.beans.factory.annotation.Qualifier;\r\n   import org.springframework.context.ApplicationContext;\r\n   import org.springframework.test.context.ContextConfiguration;\r\n   import org.springframework.test.context.junit.jupiter.SpringExtension;\r\n   \r\n   import myapp.imp.StderrLogger;\r\n   import myapp.services.ICalculator;\r\n   import myapp.services.ILogger;\r\n   \r\n   @ExtendWith(SpringExtension.class)\r\n   @ContextConfiguration(classes = AppConfig.class)\r\n   public class TestAppConfigJunit {\r\n   \r\n       @Autowired\r\n       ApplicationContext context;\r\n   \r\n       @Autowired\r\n       StderrLogger stderrLogger;\r\n   \r\n       @Autowired\r\n       ICalculator calculator;\r\n   \r\n       @Test\r\n       public void testStderrLogger() {\r\n           stderrLogger.log(\"hello on stderr\");\r\n       }\r\n   \r\n       @Autowired\r\n       @Qualifier(\"file\")\r\n       ILogger fileLogger;\r\n   \r\n       @Test\r\n       public void testFileLogger() {\r\n           fileLogger.log(\"hello on file\");\r\n       }\r\n   \r\n       @Test\r\n       public void testCalculator() {\r\n           assertEquals(30, calculator.add(10, 20));\r\n       }\r\n   \r\n   }\r\n   ```\r\n\r\n## Nouvelles implantations\r\n\r\nNotre premi\u00E8re version de la calculatrice m\u00E9lange du code m\u00E9tier (addition) et du code de trace. Ce n'est pas une tr\u00E8s bonne id\u00E9e. Proposez une nouvelle implantation de d\u00E9coration de la calculatrice qui est construite sur deux param\u00E8tres :\r\n\r\n-  une r\u00E9f\u00E9rence vers une autre implantation de la calculatrice (qui ne fait aucune trace),\r\n-  une r\u00E9f\u00E9rence vers une implantation de la couche logger,\r\n\r\nCe d\u00E9corateur va retransmettre les requ\u00EAtes et y associer une trace.",
    tags: [],
    published: "23/10/2020",
    //author: "Nicolas Desnoust",
    authorId: "nicolas-desnoust",
    category: "spring"
  },
];